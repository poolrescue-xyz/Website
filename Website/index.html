<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>PoolRescue — Recover stranded liquidity. Fast.</title>

  <meta name="description" content="Recover stranded liquidity. Fast. We scan your abandoned or migrated liquidity positions and help you exit."/>
  <link rel="canonical" href="https://www.poolrescue.xyz/"/>
  <link rel="me" href="https://x.com/PoolRescue_xyz">
  <meta name="twitter:site" content="@PoolRescue_xyz">
  <meta name="robots" content="index,follow,max-snippet:-1,max-image-preview:large,max-video-preview:-1"/>

  <meta property="og:title" content="PoolRescue — Recover stranded liquidity. Fast."/>
  <meta property="og:description" content="Recover stranded liquidity. Fast. We scan your abandoned or migrated liquidity positions and help you exit."/>
  <meta property="og:type" content="website"/>
  <meta property="og:url" content="https://www.poolrescue.xyz/"/>
  <meta property="og:image" content="https://www.poolrescue.xyz/poolrescue_favicon_512.jpg"/>

  <meta name="twitter:card" content="summary_large_image"/>
  <meta name="twitter:title" content="PoolRescue — Recover stranded liquidity. Fast."/>
  <meta name="twitter:description" content="Recover stranded liquidity. Fast. We scan your abandoned or migrated liquidity positions and help you exit."/>
  <meta name="twitter:image" content="https://www.poolrescue.xyz/poolrescue_favicon_512.jpg"/>

  <meta name="theme-color" content="#0f172a"/>

  <link rel="icon" type="image/png" sizes="32x32" href="./poolrescue_logo_from_source_56.png">
  <link rel="icon" type="image/jpeg" sizes="512x512" href="./poolrescue_favicon_512.jpg">
  <link rel="apple-touch-icon" href="./poolrescue_favicon_512.jpg">
  <link rel="preload" as="image" href="./poolrescue_logo_from_source_56.png"/>

  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">

  <script type="application/ld+json">
  {
    "@context":"https://schema.org",
    "@type":"WebApplication",
    "name":"PoolRescue",
    "applicationCategory":"DeFiTool",
    "operatingSystem":"Web",
    "url":"https://www.poolrescue.xyz/",
    "image":"https://www.poolrescue.xyz/poolrescue_favicon_512.jpg",
    "description":"Recover stranded liquidity. Fast. We scan your abandoned or migrated liquidity positions and help you exit."
  }
  </script>

  <style>
    :root{--fg:#0f172a;--muted:#64748b;--line:#e5e7eb;--bg:#fff;--btn:#111}
    *{box-sizing:border-box}
    body{font-family:system-ui,Segoe UI,Roboto;margin:0;background:var(--bg);color:var(--fg)}
    .wrap{max-width:1280px;margin:28px auto;padding:0 20px}
    .header-row{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
    h1{font-size:28px;margin:0 0 6px}
    .pill{display:inline-block;padding:4px 10px;border-radius:999px;background:#f1f5f9;border:1px solid #e5e7eb;font-size:13px;margin-left:10px}
    .header-actions{display:flex;gap:10px;align-items:center}
    a.link-chip{font-size:13px;padding:6px 10px;border:1px solid #e5e7eb;border-radius:999px;text-decoration:none;color:#FFFFFF;background:#000000}
    a.link-chip:hover{background:#808080}
    .sub{color:var(--muted);font-size:13px}
    .card{border:1px solid var(--line);border-radius:12px;padding:16px;margin:16px 0;box-shadow:0 1px 3px rgba(0,0,0,.05)}
    .grid{display:grid;grid-template-columns:repeat(12,1fr);gap:12px}
    .c3{grid-column:span 3}.c4{grid-column:span 4}.c6{grid-column:span 6}.c9{grid-column:span 9}
    label{display:block;font-weight:600;margin:6px 0}
    input,button,select{padding:11px;border-radius:10px;border:1px solid #cbd5e1;width:100%}
    button{cursor:pointer}.btn{background:var(--btn);color:#fff;border-color:var(--btn)}
    .status{padding:10px 12px;border-radius:10px;background:#f1f5f9;display:inline-block;min-height:40px}
    .ok{color:#047857;font-weight:600}.bad{color:#b91c1c;font-weight:600}
    table{width:100%;border-collapse:collapse;margin-top:12px;table-layout:fixed}
    th,td{border-bottom:1px solid #eee;padding:10px;text-align:left;vertical-align:top;word-break:break-word}
    thead th:nth-child(1){width:120px}
    thead th:nth-child(2){width:20%}
    thead th:nth-child(3), thead th:nth-child(4){width:13%}
    thead th:nth-child(5){width:18%}
    thead th:nth-child(6){width:18%}
    thead th:nth-child(7){width:13%}
    thead th:nth-child(8){width:180px}
    .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
    .muted{color:#64748b}.small{font-size:12px}
    .actions{display:flex;gap:8px;flex-wrap:wrap}
    pre{background:#fafafa;border:1px solid #eee;border-radius:8px;padding:10px;max-height:260px;overflow:auto;white-space:pre-wrap}
    .log-strong{font-weight:700}
    .dropdown{position:relative}
    .dd-head{display:flex;align-items:center;gap:8px;justify-content:space-between;cursor:pointer}
    .dd-menu{position:absolute;left:0;right:0;top:100%;z-index:10;background:#fff;border:1px solid #e5e7eb;border-radius:12px;padding:8px;margin-top:6px;box-shadow:0 10px 24px rgba(0,0,0,.08)}
    .dd-search{margin:4px 0 6px}
    .dd-list{max-height:320px;overflow:auto;border:1px solid #f1f5f9;border-radius:10px}
    .dd-row{display:flex;gap:8px;align-items:flex-start;padding:6px 8px;border-bottom:1px dashed #f3f4f6}
    .dd-row:last-child{border-bottom:none}
    .dd-title{font-weight:600;margin-bottom:0}
    .dd-lines{line-height:1.25}
    .dd-line{display:flex;gap:6px;align-items:center}
    .dd-k{min-width:44px;color:#64748b}
    .dd-foot{display:flex;gap:8px;margin-top:8px;align-items:center}

    @media (max-width: 860px){
      .wrap{padding:0 14px}
      .grid{grid-template-columns:repeat(12,1fr);gap:10px}
      .c4,.c6,.c9,.c3{grid-column:span 12}
      thead{display:none}
      table,tbody,tr,td{display:block;width:100%}
      tbody tr{border:1px solid #eee;border-radius:10px;padding:8px;margin-bottom:12px}
      td{border:none;padding:6px 0}
      td::before{content:attr(data-label);display:block;font-size:12px;color:#64748b;margin-bottom:2px}
      .actions{flex-direction:column}
      .actions button{width:100%}
      .dd-menu{position:fixed;left:14px;right:14px;top:auto;bottom:14px;max-height:70vh}
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/ethers@6.14.0/dist/ethers.umd.min.js" defer></script>
</head>
<body>
<div class="wrap">
  <div class="header-row">
    <div style="display:flex;align-items:center">
      <img src="./poolrescue_logo_from_source_56.png" alt="PoolRescue logo" width="28" height="28" decoding="async" style="border-radius:6px"/>
      <h1 style="margin:0">PoolRescue</h1>
      <span class="pill">Recover stranded liquidity. Fast.</span>
    </div>
    <div class="header-actions">
      <a class="link-chip" href="https://docs.poolrescue.xyz" target="_blank" rel="noopener">Docs</a>
      <a class="link-chip" href="https://x.com/PoolRescue_xyz" target="_blank" rel="noopener">X (Twitter)</a>
    </div>
  </div>

  <p class="sub" id="hdr">
    Recover your stranded LPs and staking rewards on <b id="hdrChain">Scroll</b>
    (<span id="hdrProtos">Skydrome & Tokan</span>).
    One-click flow: <b>Unstake (if staked) → Approve → Remove</b>.
    <span id="feeInfo" class="small"></span>
  </p>

  <div class="card">
    <div class="grid">
      <div class="c4"><label>Connect wallet</label><button id="connect">Connect</button></div>
      <div class="c4"><label>Status</label><div id="status" class="status">Wallet not connected</div></div>
      <div class="c4"><label>Watch wallet</label><input id="scanAddr" placeholder="0x… (empty = connected wallet)"/></div>
    </div>
    <div class="grid" style="margin-top:8px">
      <div class="c4">
        <label>Chain</label>
        <select id="chainSel"></select>
      </div>
      <div class="c4"><label>Protocol</label>
        <select id="protocol"></select>
      </div>
      <div class="c4 dropdown" id="poolDd">
        <label>Pool</label>
        <div class="dd-head" id="poolHead">
          <span id="poolHeadText" class="sub">All selected</span><span class="sub">▼</span>
        </div>
        <div class="dd-menu" id="poolMenu" style="display:none">
          <div class="dd-search"><input id="poolSearch" placeholder="Search name / LP / gauge"/></div>
          <div class="dd-list" id="poolList"></div>
          <div class="dd-foot">
            <button id="selAll" type="button">Select all</button>
            <button id="clrAll" type="button">Select none</button>
            <div class="sub" id="poolCount" style="margin-left:auto">All selected</div>
          </div>
        </div>
      </div>
    </div>
    <div class="grid" style="margin-top:8px;align-items:flex-end">
      <div class="c9"><button id="scan" class="btn" style="width:100%;height:44px;font-weight:600">AutoScan</button></div>
      <div class="c3"><label style="margin-bottom:2px">Slippage</label><input id="slip" value="0.5"/></div>
    </div>
  </div>

  <div class="card">
    <h3 style="margin-top:6px">Found LP positions</h3>
    <table>
      <thead><tr>
        <th>Protocol</th><th>Pair</th><th>token</th><th>token</th>
        <th>LP (Wallet / Staked)</th><th>Liquidity</th><th>Rewards</th><th>Action</th>
      </tr></thead>
      <tbody id="tbody"><tr><td colspan="8" class="sub">No scan yet.</td></tr></tbody>
    </table>
    <h4 style="margin-top:18px">LOG</h4>
    <pre id="log" class="mono">—</pre>
  </div>
</div>

<script>
(function boot(){
  if(!window.ethers){ return setTimeout(boot,40); }
  const ethers = window.ethers;

  let CHAINS = {};
const CHAIN_ORDER = [
  1,      // Ethereum
  56,     // BNB Chain
  10,     // Optimism
  8453,   // Base
  42161,  // Arbitrum
  59144,  // Linea
  43114,  // Avalanche
  137,    // Polygon
  324,    // zkSync
  534352, // Scroll
  5000,   // Mantle
  204,    // opBNB
  42170   // Arbitrum Nova
];


  async function loadChainsConfig(){
    const raw = await fetch('./chains.config.json', { cache: 'no-store' }).then(r=>r.json());
    for(const cid of Object.keys(raw)){
      const o = localStorage.getItem('PR_RPC_'+cid);
      if(o) raw[cid].rpc = o;
      try{
        const host = new URL(raw[cid].rpc).hostname;
        if(/\.?drpc\.org$/i.test(host)) raw[cid].maxConc = 2;
      }catch{}
    }
    CHAINS = raw;

    const sel = $("chainSel"); sel.innerHTML="";
    for(const id of CHAIN_ORDER){
      if(!CHAINS[id]) continue;
      const o=document.createElement('option'); o.value=String(id); o.textContent=CHAINS[id].name; sel.appendChild(o);
    }
    for(const cid of Object.keys(CHAINS)){
      if(!CHAIN_ORDER.includes(Number(cid))){
        const o=document.createElement('option'); o.value=cid; o.textContent=CHAINS[cid].name; $("chainSel").appendChild(o);
      }
    }
    if(sel.options.length) sel.value = sel.options[0].value;
  }

  const ERC20=[ "function symbol() view returns(string)",
                "function decimals() view returns(uint8)",
                "function balanceOf(address) view returns(uint256)",
                "function allowance(address,address) view returns(uint256)",
                "function approve(address,uint256) returns(bool)" ];
  const ADAPTER_ABI=[ "function removeWithFee(address pair,uint256 lpAmount,uint256 min0,uint256 min1)",
                      "function feeBps() view returns(uint16)" ];

  const ABI_EARNED_TOKEN_ACCOUNT   = ["function earned(address token,address account) view returns(uint256)"];
  const ABI_GET_REWARD_ADDR_TOKENS = ["function getReward(address account, address[] tokens)"];
  const ABI_EARNED_ACCOUNT_ONLY    = ["function earned(address account) view returns (uint256)"];
  const ABI_CLAIM_NOARGS           = ["function getReward()"];
  const ABI_CLAIMABLE_REWARD       = ["function claimableReward(address _user,address _reward_token) view returns(uint256)"];
  const ABI_CLAIM_REWARDS          = ["function claimRewards()"];
  const ABI_EARNED_USER_TOKEN      = ["function earned(address account,address token) view returns(uint256)"];

  function isSolType(tok){
    return /^(u?int|address|bool|bytes|string)/.test((tok||"").trim());
  }

  function normalizeOutputs(sig){
    if(!sig || typeof sig !== "string") return "";
    const parts = sig.split(",").map(p => p.trim()).filter(Boolean);
    const out = parts.map(p => {
      const bits = p.split(/\s+/).filter(Boolean);
      if(bits.length === 1){
        return bits[0];
      }
      const a = bits[0], b = bits[1];
      const aIsType = isSolType(a);
      const bIsType = isSolType(b);
      if(aIsType && !bIsType){
        return bits.join(" ");
      }
      if(!aIsType && bIsType){
        return `${b} ${a}`;
      }
      return bits.join(" ");
    });
    return out.join(",");
  }

  function chefReadABI(spec){
    const poolInfoFn = (spec && spec.chefPoolInfoFn) || "poolInfo(uint256)";
    const userInfoFn = (spec && spec.chefUserInfoFn) || "userInfo(uint256,address)";
    const pendingSig = (spec && spec.chefPendingFn) || "pendingCC(uint256,address)";

    const poolInfoOut = normalizeOutputs(
      (spec && spec.chefPoolInfoOutputs) ||
      "address lpToken,uint256,uint256,uint256,uint256,uint256,uint256"
    );
    const userInfoOut = normalizeOutputs(
      (spec && spec.chefUserInfoOutputs) ||
      "uint256,uint256,uint256,uint256,uint256"
    );

    return [
      "function poolLength() view returns (uint256)",
      `function ${poolInfoFn} view returns (${poolInfoOut})`,
      `function ${userInfoFn} view returns (${userInfoOut})`,
      `function ${pendingSig} view returns (uint256)`
    ];
  }
  
  function chefWriteABI(spec){
    const abi = [];
    const wSig = (spec && spec.chefWithdrawSig) || "withdraw(uint256 _pid, uint256 _lpAmount, uint256 _boostAmount)";
    abi.push(`function ${wSig}`);
    return abi;
  }


  const IF_TOKENS = new ethers.Interface(["function tokens() view returns(address,address)"]);
  const IF_T0     = new ethers.Interface(["function token0() view returns(address)"]);
  const IF_T1     = new ethers.Interface(["function token1() view returns(address)"]);
  const IF_RES    = new ethers.Interface(["function getReserves() view returns(uint112,uint112,uint32)"]);
  const IF_R0     = new ethers.Interface(["function reserve0() view returns(uint256)"]);
  const IF_R1     = new ethers.Interface(["function reserve1() view returns(uint256)"]);
  const IF_TS     = new ethers.Interface(["function totalSupply() view returns(uint256)"]);
  const IF_BAL    = new ethers.Interface(["function balanceOf(address) view returns(uint256)"]);
  const MC_ABI    = ["function aggregate3((address target,bool allowFailure,bytes callData)[] calls) payable returns (tuple(bool,bytes)[] r)"];
  const GAUGE_BAL_ABI = ["function balanceOf(address) view returns (uint256)"];
  const GAUGE_WD_ABI  = ["function withdraw(uint256)","function withdrawAll()"];

  
  
  const MC_ABI3 = [
    "function aggregate3((address target,bool allowFailure,bytes callData)[] calls) payable returns (tuple(bool success, bytes returnData)[] returnData)"
  ];
  const TOKEN_META = new Map(); 
  const PAIR_META  = new Map();

  const IF_SYM_STR = new ethers.Interface(['function symbol() view returns (string)']);
  const IF_SYM_B32 = new ethers.Interface(['function symbol() view returns (bytes32)']);
  const IF_DEC     = new ethers.Interface(['function decimals() view returns (uint8)']);

  const MC_MAX_CALLS_PER_TX = 180;
  const MC_PAIRS_PER_BATCH  = 15;

  function chunk(arr, n){ const out=[]; for(let i=0;i<arr.length;i+=n) out.push(arr.slice(i,i+n)); return out; }
  const sleep = (ms)=> new Promise(r=>setTimeout(r,ms));

  async function mc3Bundle(calls){
    if(!calls.length) return [];
    const mc = new ethers.Contract(MC3, MC_ABI3, providerFast);
    const batches = chunk(calls, MC_MAX_CALLS_PER_TX);
    const out = [];
    for(const pack of batches){
      Logger.bumpRpc(1);
      const res = await mc.aggregate3.staticCall(pack.map(x=>({target:x.target, allowFailure:true, callData:x.callData})));
      out.push(...res);
      await sleep(CHAINS[CHAIN_ID]?.jitterMs || 0);
    }
    return out;
  }

  function decodeB32Sym(b){
    try{
      const hex = typeof b === "string" ? b : ethers.hexlify(b);
      let s = hex.replace(/^0x/i,"");
      while (s.length >= 2 && s.slice(-2) === "00") s = s.slice(0, -2);
      const trimmed = "0x" + s;
      return ethers.toUtf8String(trimmed);
    }catch{ return "TOKEN"; }
  }

  async function prefetchPairMetaBatch(pairs, hints = new Map()){
    const need = pairs.map(p=>p.toLowerCase()).filter(p=>!PAIR_META.has(p));
    if(!need.length) return;

    const perPairCalls = (addr)=>([
      { target: addr, callData: IF_TOKENS.encodeFunctionData("tokens",[]) },
      { target: addr, callData: IF_T0.encodeFunctionData("token0",[]) },
      { target: addr, callData: IF_T1.encodeFunctionData("token1",[]) },
      { target: addr, callData: IF_TS.encodeFunctionData("totalSupply",[]) },
      { target: addr, callData: IF_RES.encodeFunctionData("getReserves",[]) },
    ]);

    for(const group of chunk(need, MC_PAIRS_PER_BATCH)){
      const calls = group.flatMap(perPairCalls);
      const res   = await mc3Bundle(calls);

      for(let i=0;i<group.length;i++){
        const base = i*5;
        const pair = group[i];
        let t0=null, t1=null, ts=0n, r0=0n, r1=0n;

        if(res[base+0][0]){ try{ const [a,b]=IF_TOKENS.decodeFunctionResult("tokens",res[base+0][1]); t0=a; t1=b; }catch{} }
        if((!t0||!t1) && res[base+1][0]){ try{ t0 = IF_T0.decodeFunctionResult("token0",res[base+1][1])[0]; }catch{} }
        if((!t0||!t1) && res[base+2][0]){ try{ t1 = IF_T1.decodeFunctionResult("token1",res[base+2][1])[0]; }catch{} }

        if((!t0||!t1) && hints.has(pair)){
          const h = hints.get(pair);
          if(!t0 && h?.t0) t0=h.t0;
          if(!t1 && h?.t1) t1=h.t1;
        }
        if(!t0 || !t1){ continue; }

        if(res[base+3][0]){ try{ ts = BigInt(IF_TS.decodeFunctionResult("totalSupply",res[base+3][1])[0]); }catch{} }
        if(res[base+4][0]){
          try{
            const [R0,R1] = IF_RES.decodeFunctionResult("getReserves",res[base+4][1]);
            r0 = BigInt(R0); r1 = BigInt(R1);
          }catch{}
        }

        PAIR_META.set(pair, { t0, t1, ts, r0, r1 });
      }
    }
  }

  async function prefetchTokenMetaBatch(tokens){
    const need = tokens.map(x=>x.toLowerCase()).filter(a=>!TOKEN_META.has(a));
    if(!need.length) return;

    const calls = [];
    for(const t of need){
      calls.push({ target:t, callData: IF_DEC.encodeFunctionData("decimals",[]) });
      calls.push({ target:t, callData: IF_SYM_STR.encodeFunctionData("symbol",[]) });
    }
    const r1 = await mc3Bundle(calls);

    const missForSymbolB32 = [];
    for(let i=0;i<need.length;i++){
      const t = need[i]; const dIdx=i*2, sIdx=i*2+1;
      let dec=null, sym=null;

      if(r1[dIdx][0]){ try{ dec = Number(IF_DEC.decodeFunctionResult("decimals",r1[dIdx][1])[0]); }catch{} }
      if(r1[sIdx][0]){ try{ sym = String(IF_SYM_STR.decodeFunctionResult("symbol",r1[sIdx][1])[0]); }catch{} }

      if(sym===null) missForSymbolB32.push(t);
      TOKEN_META.set(t, { sym, dec });
    }

    if(missForSymbolB32.length){
      const calls2 = missForSymbolB32.map(t=>({target:t,callData:IF_SYM_B32.encodeFunctionData("symbol",[])}));
      const r2 = await mc3Bundle(calls2);
      missForSymbolB32.forEach((t, i)=>{
        const ok = r2[i][0];
        if(ok){
          try{
            const b32 = IF_SYM_B32.decodeFunctionResult("symbol",r2[i][1])[0];
            const cur = TOKEN_META.get(t) || {};
            TOKEN_META.set(t, { sym: cur.sym || decodeB32Sym(b32), dec: cur.dec ?? 18 });
          }catch{
            const cur = TOKEN_META.get(t) || {};
            TOKEN_META.set(t, { sym: cur.sym || "TOKEN", dec: cur.dec ?? 18 });
          }
        }
      });
    }

    for(const t of need){
      const cur = TOKEN_META.get(t) || {};
      TOKEN_META.set(t, { sym: cur.sym || "TOKEN", dec: (cur.dec ?? 18) });
    }
  }
  
  async function prefetchGaugeBalancesBatch(list, account){
    const entries = [];
    const idxMap = new Map();
    let i = 0;

    for (const p of list){
      if (p.gauge && isAddr(p.gauge) && !isChefProto(p.spec)){
        const pairLower = p.pair.toLowerCase();
        const callData  = IF_BAL.encodeFunctionData("balanceOf",[account]);
        entries.push({ target: p.gauge, callData });
        idxMap.set(i++, { pairLower, gauge: p.gauge });
      }
    }

    const out = new Map();
    if (entries.length){
      const GAUGE_BATCH = 10;
      let res = [];
      for (const sub of chunk(entries, GAUGE_BATCH)) {
        const part = await mc3Bundle(sub);
        res.push(...part);
        await sleep(CHAINS[CHAIN_ID]?.jitterMs || 50);
      }

      for (let j = 0; j < res.length; j++){
        const meta = idxMap.get(j);
        if (!meta) continue;
        const { pairLower, gauge } = meta;

        let v = 0n;
        if (res[j][0]) {
          try{
            v = BigInt(IF_BAL.decodeFunctionResult("balanceOf", res[j][1])[0]);
          } catch (e){
            console.warn("Gauge decode failed:", gauge, "rawReturnData:", res[j][1], e);
            v = 0n;
          }
        }
        out.set(pairLower, v);
      }
    }
    return out;
  }



  const $=id=>document.getElementById(id);
  const fmt=(v,dec=18)=>{try{return Number(ethers.formatUnits(v,dec)).toFixed(5)}catch{return "0.00000"}}
  const isAddr=a=>{try{return ethers.isAddress((a||"").trim())}catch{return false}}
  function tsLocal(d=new Date()){
    const pad=n=>String(n).padStart(2,'0');
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
  }
  const isChefProto = (spec)=> spec && spec.rewardType === "chef";

  const Logger = (() => {
    const pre = () => document.getElementById('log');
    let startMs = 0, totalPlanned = 0, lastPrinted = -1;
    let seenNotes = new Set();
    const ctr = { rpcTotal:0, errors:0 };
    let planned = { pairs:0, gauge:0, rewards:0 };

    function lineTs(tsStr, html){
      const el = pre(); if(!el) return;
      el.innerHTML = `[${tsStr}] ${html}\n` + (el.innerHTML==="—"?"":el.innerHTML);
    }
    function line(html){ lineTs(tsLocal(), html); }
    function reset(){ ctr.rpcTotal=0; ctr.errors=0; planned={pairs:0,gauge:0,rewards:0}; }

    return {
      clear(){ seenNotes = new Set(); const el=pre(); if(el) el.innerHTML="—"; },
      start(total, meta, plans={pairs:0,gauge:0,rewards:0}){
        startMs = Date.now();
        totalPlanned = Number(total||0);
        lastPrinted = -1;
        seenNotes = new Set();
        reset();
        planned = plans;
        if(totalPlanned>0) line(`selected pools to scan: ${totalPlanned}`);
      },
      note(msg){ if(seenNotes.has(msg)) return; seenNotes.add(msg); line(msg); },
      progress(done, total=totalPlanned){
        let d = Number(done), t = Number(total);
        if(Number.isNaN(d)||Number.isNaN(t)) return;
        if(d>t) d = t;
        if(d===t){ if(lastPrinted!==t){ lastPrinted=t; line(`progress: ${d}/${t}`); } return; }
        if(d>0 && d%50===0 && d!==lastPrinted){ lastPrinted=d; line(`progress: ${d}/${t}`); }
      },
      bumpRpc(n=1){ ctr.rpcTotal += Number(n)||0; },
      error(e){ ctr.errors += 1; const msg=(e&&e.message)||e||"error"; line(`error: ${msg}`); },
      finish(foundCount){
        const ms = Math.max(0, Date.now() - startMs);
        const secs = (ms/1000).toFixed(3);
        const rate = (ctr.rpcTotal / Math.max(ms/1000,0.001)).toFixed(1);
        line(`elapsed time ${secs}sec · RPC Calls ${ctr.rpcTotal} · avg ${rate} calls/s · checked pairs ${planned.pairs} · checked gauge ${planned.gauge} · checked rewards ${planned.rewards} · errors ${ctr.errors}`);
        line(`Scan finished:  <span class="log-strong">${foundCount} LP position(s) found</span>`);
      }
    };
  })();

  let providerFast, MC3, ADAPTER, RPC, CHAIN_ID;
  let provider, signer, account, currentFeeBps=100n;
  let POOLS=[], selectedPairs=new Set();

  function updateWalletUI(){
    const st  = $("status");
    const btn = $("connect");
    if(!st || !btn) return;

    if(account){
      btn.textContent = "Connected";
      st.textContent  = `Connected ${account.slice(0,6)}…${account.slice(-4)}`;
      st.className    = "status ok";
    }else{
      btn.textContent = "Connect";
      st.textContent  = "Wallet not connected";
      st.className    = "status";
    }
  }

  async function initWallet(){
    if(!window.ethereum){
      updateWalletUI();
      return;
    }

    if(!provider) provider = new ethers.BrowserProvider(window.ethereum);

    window.ethereum.removeAllListeners?.("accountsChanged");
    window.ethereum.removeAllListeners?.("chainChanged");
    window.ethereum.removeAllListeners?.("disconnect");

    window.ethereum.on("accountsChanged", async (accs)=>{
      if(!accs || !accs.length){
        account = null;
        signer  = null;
        Logger.note("wallet disconnected (accountsChanged)");
      }else{
        account = accs[0].toLowerCase();
        try { signer = await provider.getSigner(); } catch{}
        Logger.note("wallet account changed");
      }
      updateWalletUI();
    });

    window.ethereum.on("chainChanged", async (chainIdHex)=>{
      const newId = parseInt(chainIdHex, 16);
      Logger.note(`wallet chainChanged → ${newId}`);
      if(!Number.isFinite(newId)) return;

      if(CHAINS[newId]){
        $("chainSel").value = String(newId);
        applyChain(newId);
        await readFee();
        await loadRegistries();
      }else{
        Logger.note("Unsupported chain in wallet; please switch to a supported network.");
      }
    });

    window.ethereum.on("disconnect", ()=>{
      account = null;
      signer  = null;
      Logger.note("wallet disconnected");
      updateWalletUI();
    });

    try{
      const accs = await window.ethereum.request({ method:"eth_accounts" });
      if(accs && accs.length){
        account = accs[0].toLowerCase();
        try { signer = await provider.getSigner(); } catch {}
        Logger.note("wallet auto-connected");
      }
    }catch(e){
      Logger.error(e);
    }

  updateWalletUI();

    $("connect").onclick = async ()=>{
      try{
        if(!window.ethereum){
          alert("No injected wallet (MetaMask, Rabby, …) found.");
          return;
        }
        if(!provider) provider = new ethers.BrowserProvider(window.ethereum);

        const accs = await provider.send("eth_requestAccounts", []);
        if(!accs || !accs.length) return;

        account = accs[0].toLowerCase();
        signer  = await provider.getSigner();
        updateWalletUI();
        Logger.note("wallet connected via button");

        const net = await provider.getNetwork();
        if(Number(net.chainId)!==CHAIN_ID && CHAINS[CHAIN_ID]){
          try{
            await window.ethereum.request({
              method:"wallet_switchEthereumChain",
              params:[{ chainId: "0x" + CHAIN_ID.toString(16) }]
            });
          }catch(e){
            Logger.error(e);
          }
        }
      }catch(e){
        Logger.error(e);
        account = null;
        signer  = null;
        const st = $("status");
        if(st){
          st.textContent = "Wallet not connected";
          st.className   = "status bad";
        }
        updateWalletUI();
      }
    };
  }


  const REG_MEM = new Map();
  const ss = window.sessionStorage;
  function regKey(chainId, protoKey){ return `PR_REG_${chainId}_${protoKey}`; }
  async function fetchRegistryJSON(relativePath){
    const resp = await fetch("./"+relativePath, { cache: 'no-store' });
    return await resp.text();
  }
  async function getRegistry(chainId, proto){
    const key = regKey(chainId, proto.key);
    if (REG_MEM.has(key)) return REG_MEM.get(key);
    const cached = ss.getItem(key);
    if (cached){ try{ const arr = JSON.parse(cached); REG_MEM.set(key, arr); return arr; }catch{} }
    const raw = await fetchRegistryJSON(proto.json);
    let parsed = [];
    try{ parsed = JSON.parse(raw); }catch{ parsed = []; }
    try{ ss.setItem(key, JSON.stringify(parsed)); }catch{}
    REG_MEM.set(key, parsed);
    return parsed;
  }

  function applyChain(cid){
    const cfg = CHAINS[cid];
    CHAIN_ID = Number(cid); RPC = cfg.rpc; ADAPTER = cfg.adapter; MC3 = cfg.mc3;
    providerFast = new ethers.JsonRpcProvider(
      RPC,
      { chainId: CHAIN_ID, name: cfg.name },
      { staticNetwork: true }
    );
    Logger.clear();
    $("hdrChain").textContent = cfg.name;
    $("hdrProtos").textContent = cfg.protocols.map(p=>p.label).join(" & ");
    $("feeInfo").textContent = "—";

    const sel = $("protocol"); 
    sel.innerHTML = "";

    const protos = [...cfg.protocols].sort((a, b) => a.label.localeCompare(b.label));

    if (protos.length > 1) {
      const o = document.createElement("option");
      o.value = "all";
      o.textContent = "All";
      sel.appendChild(o);
    }

    protos.forEach(p => {
      const o = document.createElement("option");
      o.value = p.key;
      o.textContent = p.label;
      sel.appendChild(o);
    });

    sel.value = (protos.length > 1) ? "all" : protos[0].key;
  }

  async function ensureWallet(){
    if(!window.ethereum) throw new Error("no wallet");
    if(!provider) provider=new ethers.BrowserProvider(window.ethereum);
    const net=await provider.getNetwork();
    if(Number(net.chainId)!==CHAIN_ID){
      try{ await window.ethereum.request({method:"wallet_switchEthereumChain",params:[{chainId:"0x"+CHAIN_ID.toString(16)}]}); }catch{}
    }
  }


  async function readFee(){
    try{ const c=new ethers.Contract(ADAPTER,ADAPTER_ABI,providerFast); Logger.bumpRpc(1); currentFeeBps=BigInt(await c.feeBps()); }catch{}
    $("feeInfo").textContent=`Current fee: ${(Number(currentFeeBps)/100).toFixed(2)}% (Adapter ${ADAPTER.slice(0,6)}…${ADAPTER.slice(-4)})`;
  }

  const ddHead=$("poolHead"), ddMenu=$("poolMenu"), ddList=$("poolList"), ddSearch=$("poolSearch");
  ddHead.onclick=()=>{ddMenu.style.display=ddMenu.style.display==="none"?"block":"none"};
  document.addEventListener('click',e=>{ if(!$("poolDd").contains(e.target)) ddMenu.style.display="none"; });
  function updatePoolHead(){
    const total=POOLS.length, sel=selectedPairs.size;
    const all=sel===total && total>0, none=sel===0;
    $("poolCount").textContent=all?"All selected":(none?"All pools":`${sel}/${total} selected`);
    $("poolHeadText").textContent=all?"All selected":(none?"All pools":`${sel} selected`);
  }
  function renderPoolDropdown(){
    ddList.innerHTML="";
    const q=(ddSearch.value||"").toLowerCase();
    for(const p of POOLS){
      if(q && !(p.name.toLowerCase().includes(q)||p.pair.toLowerCase().includes(q)||(p.gauge||"").toLowerCase().includes(q))) continue;
      const id=`pool_${p.pair}`;
      const checked=selectedPairs.has(p.pair.toLowerCase())?"checked":"";
      const row=document.createElement('div');row.className="dd-row";
      row.innerHTML=`
        <input type="checkbox" id="${id}" data-addr="${p.pair}" ${checked}>
        <label for="${id}" style="flex:1">
          <div class="dd-title">${p.name}</div>
          <div class="dd-lines small">
            <div class="dd-line"><span class="dd-k">LP:</span><span class="mono muted">${p.pair}</span></div>
            <div class="dd-line"><span class="dd-k">Gauge:</span><span class="mono muted">${p.gauge||"—"}</span></div>
          </div>
          <div class="small muted">${p.protocol}</div>
        </label>`;
      ddList.appendChild(row);
    }
    updatePoolHead();
  }
  ddList.addEventListener('change',e=>{
    const cb=e.target; if(!cb.matches('input[type="checkbox"]')) return;
    const addr=(cb.getAttribute('data-addr')||"").toLowerCase();
    if(cb.checked) selectedPairs.add(addr); else selectedPairs.delete(addr);
    updatePoolHead();
  });
  ddSearch.oninput=renderPoolDropdown;
  $("selAll").onclick=()=>{selectedPairs.clear(); for(const p of POOLS) selectedPairs.add(p.pair.toLowerCase()); renderPoolDropdown()};
  $("clrAll").onclick=()=>{selectedPairs.clear(); renderPoolDropdown()};

  async function loadRegistries(){
    Logger.clear();
    const proto=$("protocol").value;
    const cfg = CHAINS[CHAIN_ID];
    const list=[];
    const addFrom = async (p)=>{
      try{
        const j = await getRegistry(CHAIN_ID, p);
        for (const x of j) {
          if (!x.pool_address) continue;

          const isActive = (x.active === undefined || x.active === null) ? true : !!x.active;
          if (!isActive) continue;

          const t0 = (x.token0 || x.token0_address || x.t0 || "").trim?.() || (x.token0 || "");
          const t1 = (x.token1 || x.token1_address || x.t1 || "").trim?.() || (x.token1 || "");
          const sym0 = x.token0_symbol || x.symbol0 || x.sym0 || null;
          const sym1 = x.token1_symbol || x.symbol1 || x.sym1 || null;
          const dec0 = (x.token0_decimals ?? x.decimals0 ?? x.dec0);
          const dec1 = (x.token1_decimals ?? x.decimals1 ?? x.dec1);
          const pairType = (x.pairType || x.pair_type || x.kind || "").toLowerCase();
          const isStable = (x.isStable !== undefined) ? !!x.isStable : null;

          list.push({
            protocol: p.label,
            name: (x.name||x.symbol||"Pool").replace("VolatileV1 AMM - ","vAMM ").replace("StableV1 AMM - ","sAMM "),
            pair: String(x.pool_address).trim(),
            gauge: String(x.gauge_address||"").trim(),
            spec: p,
            chefPid: (x.chefPid !== undefined && x.chefPid !== null ? Number(x.chefPid) : null),
            t0: t0 || null,
            t1: t1 || null,
            sym0: sym0,
            sym1: sym1,
            dec0: (dec0!==undefined && dec0!==null) ? Number(dec0) : null,
            dec1: (dec1!==undefined && dec1!==null) ? Number(dec1) : null,
            pairType: pairType,
            isStable: isStable
          });
        }

      }catch(e){ Logger.error(e); }
    };
    if (proto==="all"){ for(const p of cfg.protocols) await addFrom(p); }
    else { const p=cfg.protocols.find(k=>k.key===proto); if(p) await addFrom(p); }

    const seen=new Set(); POOLS=[];
    for(const p of list){ const k=p.pair.toLowerCase(); if(seen.has(k)) continue; seen.add(k); POOLS.push(p); }
    selectedPairs.clear(); for(const p of POOLS) selectedPairs.add(p.pair.toLowerCase());
    renderPoolDropdown();

    $("hdrProtos").textContent = (proto==="all")
      ? cfg.protocols.map(p=>p.label).join(" & ")
      : (cfg.protocols.find(p=>p.key===proto)||cfg.protocols[0]).label;

    const protoLabel = (proto==="all")
      ? cfg.protocols.map(p=>p.label).join(", ")
      : (cfg.protocols.find(p=>p.key===proto)||cfg.protocols[0]).label;

    Logger.note(`${cfg.name} · ${protoLabel} · Total Pools: ${POOLS.length}`);
  }
  $("protocol").onchange=loadRegistries;
  $("chainSel").onchange = async ()=>{
    const cid = Number($("chainSel").value);
    applyChain(cid);
    await readFee();
    await loadRegistries();

    if(window.ethereum && account){
      try{
        await window.ethereum.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: "0x" + cid.toString(16) }]
        });
      }catch(e){
        Logger.error(e);
      }
    }
  };


  const bumpRpc = (n)=>Logger.bumpRpc(n);
  async function callDecode(to,iface,frag,args=[]){
    try{
      bumpRpc(1);
      const data=iface.encodeFunctionData(frag,args);
      const ret=await providerFast.call({to, data});
      return iface.decodeFunctionResult(frag,ret);
    }catch{return null}
  }

  async function readPairMeta(pair, hinted){
    let t0 = hinted?.t0 && isAddr(hinted.t0) ? hinted.t0 : null;
    let t1 = hinted?.t1 && isAddr(hinted.t1) ? hinted.t1 : null;

    const preferUni = (hinted?.pairType === "uniswapv2");
    if(!t0 || !t1){
      if(!preferUni){
        const tok=await callDecode(pair,IF_TOKENS,"tokens");
        if(tok&&tok.length===2){ t0=tok[0]; t1=tok[1]; }
      }
      if(!t0 || !t1){
        const a=await callDecode(pair,IF_T0,"token0");
        const b=await callDecode(pair,IF_T1,"token1");
        if(a&&b){ t0=a[0]; t1=b[0]; } else return null;
      }
    }

    const ts = await callDecode(pair,IF_TS,"totalSupply"); if(!ts) return null;

    let r0,r1; const rs=await callDecode(pair,IF_RES,"getReserves");
    if(rs){ r0=BigInt(rs[0]); r1=BigInt(rs[1]); }
    else{
      const a=await callDecode(pair,IF_R0,"reserve0");
      const b=await callDecode(pair,IF_R1,"reserve1");
      r0=a?BigInt(a[0]):0n; r1=b?BigInt(b[0]):0n;
    }
    return {t0,t1,ts:BigInt(ts[0]), r0, r1};
  }

  async function balancesMulticall(pairs,who){
    const map=new Map(); if(!pairs.length) return map;
    try{
      const mc=new ethers.Contract(MC3, MC_ABI3, providerFast);
      const calls=pairs.map(p=>({target:p,allowFailure:true,callData:IF_BAL.encodeFunctionData("balanceOf",[who])}));
      bumpRpc(calls.length);
      const r=await mc.aggregate3.staticCall(calls);
      r.forEach((x,i)=>{let v=0n;if(x[0]){try{v=BigInt(IF_BAL.decodeFunctionResult("balanceOf",x[1])[0])}catch{}} map.set(pairs[i].toLowerCase(),v)});
    }catch{}
    const todo=pairs.filter(p=>!map.has(p.toLowerCase()) || map.get(p.toLowerCase())===0n);
    if(todo.length){
      const arr = await mapLimit(
        todo,
        CHAINS[CHAIN_ID].maxConc || 8,
        async p=>{
          try{ Logger.bumpRpc(1);
               if (!/^0x[0-9a-fA-F]{40}$/.test(p)) return 0n;
               const c=new ethers.Contract(p,ERC20,providerFast);
               return await c.balanceOf(who);
          }catch{ return 0n }
        }
      );
      arr.forEach((v,i)=>map.set(todo[i].toLowerCase(),BigInt(v||0n)));
    }
    return map;
  }
  async function mapLimit(items,lim,fn){
    const out=[];let i=0,active=0;
    const cap = CHAINS[CHAIN_ID].maxConc || Math.min(lim, 12);
    return await new Promise(res=>{
      const step=()=>{ 
        while(active<cap && i<items.length){
          const idx=i++; active++;
          Promise.resolve(fn(items[idx],idx))
            .then(v=>out[idx]=v)
            .catch(e=>{Logger.error(e); out[idx]=undefined})
            .finally(()=>{
              active--;
              if(i===items.length && active===0) res(out); else step();
            });
        }
      };
      step();
    });
  }

  async function chefBuildPidMap(chefAddr, spec){
    const chefRead = new ethers.Contract(chefAddr, chefReadABI(spec), providerFast);
    Logger.bumpRpc(1);
    const n = Number(await chefRead.poolLength());
    const pidToLp = new Map(); 
    const lpToPid = new Map();

    const poolInfoFn = (spec && spec.chefPoolInfoFn) || "poolInfo(uint256)";
    const lpIdx = (spec && typeof spec.chefLpIdx === "number") ? spec.chefLpIdx : 0;

    await mapLimit(Array.from({length:n},(_,i)=>i), 8, async pid=>{
      try{
        Logger.bumpRpc(1);
        const info = await chefRead[poolInfoFn](pid);
        const lp = String(info[lpIdx]).toLowerCase();
        pidToLp.set(pid, lp);
        lpToPid.set(lp, pid);
      }catch(e){ Logger.error(e); }
    });
    return { pidToLp, lpToPid };
  }


async function chefReadUser(chefAddr, pid, user, spec){
  const chefRead = new ethers.Contract(chefAddr, chefReadABI(spec), providerFast);

  let amount = 0n, proxyLP = 0n, boostAmt = 0n;
  try{
    Logger.bumpRpc(1);
    const userInfoFn = (spec && spec.chefUserInfoFn) || "userInfo(uint256,address)";
    const ui = await chefRead[userInfoFn](pid, user);

    const amountIdx = (spec && typeof spec.chefAmountIdx === "number") ? spec.chefAmountIdx : null;
    const proxyIdx  = (spec && typeof spec.chefProxyIdx  === "number") ? spec.chefProxyIdx  : null;
    const boostIdx  = (spec && typeof spec.chefBoostIdx  === "number") ? spec.chefBoostIdx  : null;

    amount   = BigInt( (amountIdx!==null ? ui[amountIdx] : (ui.lpAmount ?? ui.amount ?? ui[0] ?? 0n)) || 0n );
    proxyLP  = BigInt( (proxyIdx !==null ? ui[proxyIdx]  : (ui.proxyLPAmount ?? 0n)) || 0n );
    boostAmt = BigInt( (boostIdx !==null ? ui[boostIdx]  : (ui.boostAmount ?? ui[1] ?? 0n)) || 0n );
  }catch(e){
    Logger.error(e);
    return { lpAmount:0n, proxyLP:0n, boostAmt:0n, withdrawable:0n, pending:0n };
  }

  const withdrawable = proxyLP>0n ? (amount - proxyLP) : amount;

  let pending = 0n;
  try{
    Logger.bumpRpc(1);
    const pendingFn = (spec && spec.chefPendingFn) || "pendingCC(uint256,address)";
    const p = await chefRead[pendingFn](pid, user);
    pending = BigInt(p || 0n);
  }catch(e){
    const msg = (e && (e.message||"")).toLowerCase();
    if (!(msg.includes("missing revert data") ||
          msg.includes("call_exception") ||
          msg.includes("execution reverted"))) {
      Logger.error(e);
    }
    pending = 0n;
  }

  return { lpAmount:amount, proxyLP, boostAmt, withdrawable, pending };
}



  $("scan").onclick=async()=>{
    providerFast = new ethers.JsonRpcProvider(
      RPC,
      { chainId: CHAIN_ID, name: CHAINS[CHAIN_ID]?.name || "chain" },
      { staticNetwork: true }
    );
    let watch=$("scanAddr").value.trim().toLowerCase();
    if(!watch){ if(!account){ alert("Enter watch address or connect wallet."); return; } watch=account; }
    if(!isAddr(watch)){ alert("Invalid address."); return; }

    const tbody=$("tbody"); tbody.innerHTML='<tr><td colspan="8" class="sub">Scanning…</td></tr>';
    let list=[...POOLS]; if(selectedPairs.size>0) list=list.filter(p=>selectedPairs.has(p.pair.toLowerCase()));

    const gaugePlanned = list.filter(p=>p.gauge && isAddr(p.gauge)).length;
    const rewardsPlanned = gaugePlanned;
    Logger.start(list.length, null, {pairs:list.length, gauge:gaugePlanned, rewards:rewardsPlanned});

    const pairs=list.map(p=>p.pair);
    const wMap=await balancesMulticall(pairs,watch);
   const gMap = await prefetchGaugeBalancesBatch(list, watch);

    const chefPairsByChef = new Map();
    const chefSpecByChef  = new Map();

    for (const it of list) {
      if (isChefProto(it.spec) && isAddr(it.gauge)) {
        const m = chefPairsByChef.get(it.gauge) || new Map();
        const pidHint = (typeof it.chefPid === "number" && Number.isFinite(it.chefPid)) ? it.chefPid : null;
        m.set(it.pair.toLowerCase(), pidHint);
        chefPairsByChef.set(it.gauge, m);
        if (!chefSpecByChef.has(it.gauge)) chefSpecByChef.set(it.gauge, it.spec);
      }
    }

    const chefUsers = new Map();
    for (const [chefAddr, lpMap] of chefPairsByChef.entries()) {
      const spec = chefSpecByChef.get(chefAddr) || null;

      let maps = null;
      if ([...lpMap.values()].some(v => v === null)) {
        maps = await chefBuildPidMap(chefAddr, spec);
      }

      const perChef = new Map();
      chefUsers.set(chefAddr, perChef);

      const tasks = [];
      for (const [lp, pidMaybe] of lpMap.entries()) {
        const pid = (pidMaybe !== null) ? pidMaybe : maps?.lpToPid.get(lp);
        if (pid !== undefined && pid !== null) tasks.push({ lp, pid, spec });
      }

      await mapLimit(tasks, 4, async task => {
        const ui = await chefReadUser(chefAddr, task.pid, watch, task.spec);
        perChef.set(task.lp, { pid: task.pid, ...ui });
      });
    }


    
    const hints = new Map(list.map(p=>[p.pair.toLowerCase(), {t0:p.t0, t1:p.t1}]));
    await prefetchPairMetaBatch(list.map(p=>p.pair), hints);

    const uniqTokens = [];
    const seenTok = new Set();
    for (const p of list){
      const meta = PAIR_META.get(p.pair.toLowerCase());
      if(!meta) continue;
      for (const t of [meta.t0, meta.t1]){
        const k = (t||"").toLowerCase();
        if(k && !seenTok.has(k)){ seenTok.add(k); uniqTokens.push(k); }
      }
    }
    await prefetchTokenMetaBatch(uniqTokens);

    const rows=[]; let done=0;
    await mapLimit(list, 4, async item=>{
      try{
        const key=item.pair.toLowerCase();

        let wLP=BigInt(wMap.get(key)||0n);
        if(wLP===0n){
          try{
            Logger.bumpRpc(1);
            const c = new ethers.Contract(item.pair, ERC20, providerFast);
            wLP = BigInt(await c.balanceOf(watch));
          }catch(e){
            const msg = (e && (e.message || "")).toLowerCase();

            if (msg.includes("could not decode result data") && msg.includes("balanceof")) {
              console.warn("Pair balanceOf decode failed on LP:", item.pair, e);
              wLP = 0n;
              return;
            }

            if (!(msg.includes("missing revert data") || msg.includes("call_exception"))) {
              Logger.error(e);
            }
          }
        }


        let sLP=BigInt(gMap.get(key)||0n);
        let chefPid = null, chefBoost=0n, chefPending=0n;
        if(isChefProto(item.spec) && isAddr(item.gauge)){
          const perChef = chefUsers.get(item.gauge);
          const info = perChef ? perChef.get(key) : null;
          if(info){
            sLP        = BigInt(info.withdrawable||0n);
            chefBoost  = BigInt(info.boostAmt||0n);
            chefPending= BigInt(info.pending||0n);
            chefPid    = info.pid;
          }
        }

        let rewAmt=0n, rewSym="", rewDec=18;
        if(item.gauge && isAddr(item.gauge)){
          const pSpec = item.spec;
          try{
            if(isChefProto(pSpec)){
              rewAmt = chefPending;
              rewSym = (pSpec.rewardSymbol || "REWARD");
              rewDec = 18;
            }else if(pSpec.rewardType==="accountOnly"){
              Logger.bumpRpc(1);
              const gc = new ethers.Contract(item.gauge, ABI_EARNED_ACCOUNT_ONLY, providerFast);
              rewAmt = BigInt(await gc.earned(watch));
              rewSym = (pSpec.rewardSymbol || "REWARD");
              rewDec = 18;
            }else if(pSpec.rewardType==="tokenAccount" && pSpec.rewardToken){
              Logger.bumpRpc(1);
              const gc = new ethers.Contract(item.gauge, ABI_EARNED_TOKEN_ACCOUNT, providerFast);
              rewAmt = BigInt(await gc.earned(pSpec.rewardToken, watch));
              rewSym = (pSpec.rewardSymbol || "REWARD");
              rewDec = 18;
            }else if(pSpec.rewardType==="userToken_claimable" && pSpec.rewardToken){
              Logger.bumpRpc(1);
              const gc = new ethers.Contract(item.gauge, ABI_CLAIMABLE_REWARD, providerFast);
              rewAmt = BigInt(await gc.claimableReward(watch, pSpec.rewardToken));
              rewSym = (pSpec.rewardSymbol || "REWARD");
              rewDec = 18;
            }else if(pSpec.rewardType==="userToken_rewards" && pSpec.rewardToken){
              Logger.bumpRpc(1);
              const gc = new ethers.Contract(item.gauge, ABI_EARNED_USER_TOKEN, providerFast);
              rewAmt = BigInt(await gc.earned(watch, pSpec.rewardToken));
              rewSym = (pSpec.rewardSymbol || "REWARD");
              rewDec = 18;
            }
          }catch(e){
              const msg = (e && (e.message||"")).toLowerCase();
              if(!(msg.includes("missing revert data") || msg.includes("call_exception"))){
                Logger.error(e);
              }
            }
        }

        if(wLP===0n && sLP===0n && rewAmt===0n){
          done++; Logger.progress(done, list.length); return;
        }

        const meta = PAIR_META.get(item.pair.toLowerCase()) || await readPairMeta(item.pair, item);
        if(!meta){ done++; Logger.progress(done, list.length); return; }
        const {t0,t1,ts,r0,r1}=meta;

        let sym0 = (item.sym0 || null), sym1 = (item.sym1 || null);
        let dec0 = (item.dec0 ?? null), dec1 = (item.dec1 ?? null);
        const tm0 = TOKEN_META.get(t0.toLowerCase());
        if (tm0){ if(sym0===null) sym0 = tm0.sym; if(dec0===null) dec0 = tm0.dec; }
        const tm1 = TOKEN_META.get(t1.toLowerCase());
        if (tm1){ if(sym1===null) sym1 = tm1.sym; if(dec1===null) dec1 = tm1.dec; }


        if(sym0===null || dec0===null){
          try{ const c0=new ethers.Contract(t0,ERC20,providerFast); Logger.bumpRpc(sym0===null && dec0===null ? 2 : 1);
               if(sym0===null) sym0 = await c0.symbol();
               if(dec0===null) dec0 = await c0.decimals();
          }catch(e){ Logger.error(e); sym0 = sym0||"token0"; dec0 = dec0??18; }
        }
        if(sym1===null || dec1===null){
          try{ const c1=new ethers.Contract(t1,ERC20,providerFast); Logger.bumpRpc(sym1===null && dec1===null ? 2 : 1);
               if(sym1===null) sym1 = await c1.symbol();
               if(dec1===null) dec1 = await c1.decimals();
          }catch(e){ Logger.error(e); sym1 = sym1||"token1"; dec1 = dec1??18; }
        }

        const total=wLP+sLP, share= total===0n ? 0n : (total*10n**18n)/ts;
        const g0=(r0*share)/10n**18n, g1=(r1*share)/10n**18n;

        rows.push({
          canAct: (account && watch && account.toLowerCase()===watch.toLowerCase()),
          protocol:item.protocol,label:item.name,pair:item.pair, gauge:(item.gauge||ethers.ZeroAddress),
          t0,t1,sym0,sym1,dec0,dec1,wLP,sLP,g0,g1,rewAmt,rewSym,rewDec,
          spec:item.spec,
          chefPid: chefPid, chefBoost: chefBoost
        });
      }catch(e){ Logger.error(e); }
      finally{
        done++; Logger.progress(done, list.length);
      }
    });

    if(!rows.length){
      tbody.innerHTML='<tr><td colspan="8" class="sub">No LP positions or rewards found.</td></tr>';
      Logger.finish(0); return;
    }

    tbody.innerHTML="";
    for(const r of rows){
      const tr=document.createElement('tr');
      const btnLabel = r.sLP>0n ? "Withdraw & Remove Liquidity" : "Remove Liquidity";
      const hasRewards = (r.rewAmt && r.rewAmt>0n && r.gauge && r.gauge!==ethers.ZeroAddress);
      const rewardsText = hasRewards ? `${fmt(r.rewAmt,r.rewDec)} ${r.rewSym}` : "—";
      const disabledAttr = r.canAct ? "" : "disabled";
      const claimDisabled = (r.canAct && hasRewards) ? "" : "disabled";

      tr.innerHTML=`
        <td data-label="Protocol">${r.protocol}</td>
        <td data-label="Pair"><b>${r.label}</b></td>
        <td data-label="token"><b>${r.sym0}</b></td>
        <td data-label="token"><b>${r.sym1}</b></td>
        <td data-label="LP (Wallet / Staked)" class="mono">
          Wallet: ${fmt(r.wLP,18)}<br>Staked: ${fmt(r.sLP,18)}
        </td>
        <td data-label="Liquidity" class="small">
          ${fmt(r.g0,Number(r.dec0))} ${r.sym0}<br>${fmt(r.g1,Number(r.dec1))} ${r.sym1}
        </td>
        <td data-label="Rewards" class="small">${rewardsText}</td>
        <td data-label="Action">
          <div class="actions">
            <button data-one class="btn" ${disabledAttr}>${btnLabel}</button>
            <button data-claim ${claimDisabled}>Claim rewards</button>
          </div>
          ${r.canAct?"":'<div class="small muted" style="margin-top:6px">Actions are available only when a wallet is connected.</div>'}
        </td>`;
      $("tbody").appendChild(tr);

      const ensureOn=async()=>{
        if(!r.canAct) return null;
        if(!window.ethereum) throw new Error("no wallet");
        const prov=new ethers.BrowserProvider(window.ethereum);
        const net=await prov.getNetwork();
        if(Number(net.chainId)!==CHAIN_ID){
          try{ await window.ethereum.request({method:"wallet_switchEthereumChain",params:[{chainId:"0x"+CHAIN_ID.toString(16)}]}); }catch{}
        }
        return prov;
      };

      const approveIf = async (amount)=>{
        const prov = await ensureOn(); 
        if (!prov) return;

        const s = await prov.getSigner();
        const c = new ethers.Contract(r.pair, ERC20, s);
        const owner = await s.getAddress();

        Logger.bumpRpc(1);
        const curr = await c.allowance(owner, ADAPTER);

        let needed = BigInt(amount || 0n);

        const slipBps = BigInt(
          Math.round((Number($("slip").value || "0")) * 100)
        ); 

        if (slipBps > 0n) {
          needed = (needed * (10000n + slipBps)) / 10000n;
        }

        if (curr >= needed) return;

        Logger.bumpRpc(1);
        const tx = await c.approve(ADAPTER, needed);
        Logger.note(`approve ${tx.hash}`);
        await tx.wait();
        Logger.note("approve ok");
      };

      const unstakeIf=async()=>{
        if(!r.canAct) return false;
        if(r.sLP===0n || !isAddr(r.gauge)) return true;

        if(isChefProto(r.spec) && typeof r.chefPid === "number"){
          try{
            const prov=await ensureOn(); if(!prov) return false;
            const s=await prov.getSigner();
            const chefWrite = new ethers.Contract(r.gauge, chefWriteABI(r.spec), s);
            Logger.bumpRpc(1);
            const sig = (r.spec && r.spec.chefWithdrawSig) || "withdraw(uint256 _pid, uint256 _lpAmount, uint256 _boostAmount)";

            const inside   = sig.slice(sig.indexOf("(") + 1, sig.indexOf(")"));
            const argCount = inside.split(",").map(x => x.trim()).filter(Boolean).length;

            const args = (argCount >= 3)
              ? [r.chefPid, r.sLP, r.chefBoost || 0n]   
              : [r.chefPid, r.sLP];                    

            const tx = await chefWrite.withdraw(...args);

            Logger.note(`unstake chef ${tx.hash}`); await tx.wait(); Logger.note("unstake ok");
            return true;
          }catch(e){ Logger.error(e); return false; }
        }

        const prov=await ensureOn(); if(!prov) return false;
        const s=await prov.getSigner();
        for(const sig of ["withdraw(uint256)","exit()","withdrawAll()"]){
          try{
            const gc=new ethers.Contract(r.gauge,[`function ${sig}`],s);
            Logger.bumpRpc(1);
            const fn=sig.split("(")[0];
            const tx= await gc[fn](...(sig.startsWith("withdraw(")?[r.sLP]:[]));
            Logger.note(`unstake ${tx.hash}`); await tx.wait(); Logger.note("unstake ok");
            return true;
          }catch{}
        }
        alert("withdraw()* not found"); return false;
      };

      const removeAll=async()=>{
        const prov=await ensureOn(); if(!prov) return;
        const s=await prov.getSigner();
        const meta=await readPairMeta(r.pair, r); if(!meta){ alert("Pair metadata not readable."); return; }
        const {ts,r0,r1}=meta;

        const walletAddr=await s.getAddress();
        Logger.bumpRpc(1);
        const lpNow = await (new ethers.Contract(r.pair,ERC20,providerFast)).balanceOf(walletAddr);
        if(lpNow===0n){alert("No LP in wallet.");return}
        const slipBps=BigInt(Math.round((Number($("slip").value||'0'))*100));
        const share=(lpNow*10n**18n)/ts;
        const min0=(r0*share/10n**18n)*(10000n-slipBps)/10000n;
        const min1=(r1*share/10n**18n)*(10000n-slipBps)/10000n;
        const ac=new ethers.Contract(ADAPTER,ADAPTER_ABI,s);
        Logger.bumpRpc(1);
        const tx=await ac.removeWithFee(r.pair,lpNow,min0,min1);
        Logger.note(`remove ${tx.hash}`); await tx.wait(); Logger.note("remove ok");
      };

      const claim=async()=>{
        if(!r.canAct || !(r.rewAmt>0n) || !isAddr(r.gauge)) return;
        const prov=await ensureOn(); if(!prov) return;
        const s=await prov.getSigner();
        const pSpec = r.spec;
        try {
          if (isChefProto(pSpec) && typeof r.chefPid === "number") {
            const chefWrite = new ethers.Contract(r.gauge, chefWriteABI(pSpec), s); Logger.bumpRpc(1);
            const sig = (pSpec && pSpec.chefWithdrawSig) || "withdraw(uint256 _pid, uint256 _lpAmount, uint256 _boostAmount)";

            const inside   = sig.slice(sig.indexOf("(") + 1, sig.indexOf(")"));
            const argCount = inside.split(",").map(x => x.trim()).filter(Boolean).length;

            const args = (argCount >= 3)
              ? [r.chefPid, 0n, 0n]   // pid, lpAmount=0, boostAmount=0
              : [r.chefPid, 0n];      // pid, lpAmount=0

            const tx = await chefWrite.withdraw(...args);


            Logger.note(`claim chef harvest ${tx.hash}`); await tx.wait(); Logger.note("claim ok");
          } else if (pSpec.claim === "noArgs") {
            const gc = new ethers.Contract(r.gauge, ABI_CLAIM_NOARGS, s); Logger.bumpRpc(1);
            const tx = await gc.getReward();
            Logger.note(`claim ${pSpec.label} getReward() ${tx.hash}`); await tx.wait(); Logger.note("claim ok");
          } else if (pSpec.claim === "addrTokens" && pSpec.rewardToken) {
            const gc = new ethers.Contract(r.gauge, ABI_GET_REWARD_ADDR_TOKENS, s);
            const me = await s.getAddress(); Logger.bumpRpc(1);
            const tx = await gc.getReward(me, [pSpec.rewardToken]);
            Logger.note(`claim ${pSpec.label} getReward(addr,[token]) ${tx.hash}`); await tx.wait(); Logger.note("claim ok");
          } else if (pSpec.claim === "Claim") {
            const gc = new ethers.Contract(r.gauge, ABI_CLAIM_REWARDS, s); Logger.bumpRpc(1);
            const tx = await gc.claimRewards();
            Logger.note(`claim ${pSpec.label} claimRewards() ${tx.hash}`); await tx.wait(); Logger.note("claim ok");
          }
        }catch(e){ alert(`Claim failed on ${pSpec.label} gauge.`); Logger.error(e); }
      };

      tr.querySelector('[data-one]').onclick=async()=>{ try{ if(!r.canAct) return; const ok=await unstakeIf(); if(!ok) return; await approveIf(r.wLP+r.sLP); await removeAll(); }catch(e){ Logger.error(e); } };
      tr.querySelector('[data-claim]').onclick=claim;
    }

    Logger.finish(rows.length);
  };

  (async function init(){
    await loadChainsConfig();
    applyChain(Number($("chainSel").value || CHAIN_ORDER[0]));
    await readFee();
    await loadRegistries();
    await initWallet(); 
  })();

})();
</script>
</body>
</html>
